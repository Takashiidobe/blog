---
title: "Progressing in Programming"
date: 2019-04-11T20:41:20.201Z
draft: false
---

I've always wondered what the power of journaling was -- I'd never been the type to write all of my goals in a journal, and plan meticulously about what I was going to do -- I took everything at face value and jumped on every opportunity as it came. But no longer! It's time to begin blogging about progress. We're going to make some gains. (Not of the gym kind, of course).

Before we begin to do any growing, we have to know what to grow in! So we take this big goal and shrink it down into bite-sized pieces. So my goal is to become a better software developer by the end of the year. My reasoning is that understanding more about the basics of programming languages will help me out on the day to day, helping me understand what I need to do in order to become a better software developer.

So then, what is there to learn? Well, too much. But I'd like to improve at certain parts of programming that are ubiquitous in the field.

## C Programming

Ah, C. The language of Unix, the programming language that runs Unix, the most influential Operating System of all time. Such a powerful language, with just 32 reserved words, you too can build your own kernel in just a few thousand lines using this wildly expressive language. So C pretty much is the de facto language for compilers and Operating Systems (since they're both built in C), and this makes it a great first language to sink my teeth into. The way I'll do it is by reading through Programming in C (4th edition), which should be coming in the mail soon. I'll be littering this blog with some tidbits I learn from that book, and summarizing the key concepts there.

## Operating Systems

You've noticed I've mentioned operating systems in the section above. And of course, operating systems are invaluable to us. No one these days interacts with a computer without an operating system. So of course, learning about Operating systems should be a high priority -- especially Unix based ones. For that, I've picked up a copy of OSTEP (Operating Systems: Three Easy Pieces) to help aid in learning about virtualization (the act of taking the physical hardware and making a virtual API to interact with it, like writing to files, or editing files, spawning processes), concurrency (the act of turning this single threaded computer into one that can run multiple processes at once), and persistence (finally saving our actions to a hard disk, so they won't be overwritten on next boot up).
Operating systems are considered to be a hard topic, so I'm looking forward to the challenge! Maybe as a final project, it would be cool to make a small OS that could support file IO or do something like that.

## Compilers

Next up is Compilers, that thing that compiles your code and turns it into machine language. I don't know too much about compilers (hey, I'm a JavaScript(JS) guy, I use an interpreter), but I've always been keen on compilers ever since Babel entered the scene. If you don't know what Babel is, you'll have to know a bit about front-end web development. One of the pain points of front-end development is that we, as front-end developers, have to support fairly old browsers, and they support different features of HTML, CSS, and JS. For example, IE8 supports HTML4, CSS 2.1 (that means no media queries) and ES3 (the version of JavaScript that was standardized in 1999...). Currently, Google Chrome supports HTML5, CSS3, and ES10 (the version of JavaScript that was standardized in 2019). So of course, we could all painfully write our ES5 JavaScript to be backwards compatible with IE8, or we could ditch browser support for IE8 (a lot of firms have), but there's still a large user base that uses IE11, so it's a hard sell to drop support for that. IE11 supports HTML5, CSS3, and ES5, which is the 2009 standard of JavaScript. You get the idea. Lots of browsers to target, but to target them all, we'd have to use some subset of JavaScript from 10 years ago. Not very fun. Many years ago, a solution named Babel was released -- it takes the JavaScript that you write, and turns it into valid es5 JavaScript code. It's a compiler for JavaScript, but really, it's perhaps the best open source project out there in the JavaScript ecosystem. And to understand Babel, you have to understand compilers. Cue the JavaScript music (Babel actually has a theme song, a cover of Jeff Buckley's Hallelujah). I'd like to write my own small language too, preferably in C, so I can understand the nitty gritty of creating a compiler, and getting closer to the metal, if you will.

## C++ Programming

Ah, C++. When you program in C++, every problem looks like your thumb, and every goto leads you to a black hole. I'm kidding, by the way, I don't have any experience writing C++, so I can't tell you much about the language. It's also very popular, with uses in pretty much all industries, but especially in game development. It's an excellent way to learn about Object Oriented Programming, something I'm really lacking, and it has a wide standard library (again, something that JavaScript is sorely lacking), which handles plenty of use cases, such as std::vector<T, T> for lists, and std::array<T, T> for arrays. What more could you ask for?

## Java Programming

Java is the best and worst thing that's happened to programming in the past 20 years. Any takers on that statement? Steve Yegge said it. But it's interesting, you see, because when one refers to Java, it's kind of hard to see if someone's referring to Java or the Java Virtual Machine(JVM). Java has so many people who live and die by it (in more of the metaphoric sense), it has so many zealots that swear by it and nothing else, and become exalted to memetic heights -- the old timey people used to tell me about how Java saved them from environment dependent variables and worrying about memory management and pointers. And it's true that Java, specifically the JVM is amazing at abstracting away all the stuff that we really shouldn't be managing anyway, but one concern is that Java is just such a slow moving language -- it was in the Sun Microsystems days, and it still kind of is in the Oracle Days. But still, Java is a key language to at least know the basics of, and I myself still admire how forward thihnking the Sun Microsystems team were in developing both the JVM and Java. Truly wonderful. A+ Language indeed.

## Go Programming

Golang is the best programming language to come out in the past 10 years. How many takers do I have for that statement? Go reminds of C, but brought into the 21st century -- it has garbage collection (yay!), it can be run or compiled (the best of both worlds), the compiler can assume what types you're using, so you can say `x := 5` instead of the slightly more verbose `int x = 5;`, there are no semicolons (the compiler adds them at the end of each line for you), and it has a very small API, with a more modern standard library so that you can do what you need to, without having to know every nook and cranny of some arcane language (see: C++, Java, JavaScript). And it has a cute mascot. That's the real kicker, to be honest. Java's mascot, the Java Duke, looks like its from a 17th century sketchbook. Python doesn't have a mascot, just like JavaScript or C. Chalk a win up for the boys and girls at Google, their marketing is superb.

## Python Programming

Python is one of the most loved languages these days -- and I will say without a doubt, that it is an amazing language. Guido really outdid himself. But one thing I don't get is why there's a fork in the language. Why is there Python2 (which this Mac runs) and Python3 (which this blogger uses)? And the syntax is a bit different from the usual C derivative language syntax, but I guess that's a good thing about python, it has so many great things about it (such as lambdas from 1994), and comprehensions (everyone's favorite feature of functional programming), and a killer ecosystem (I instinctively etch `import numpy as np` for almost every .py file I write). And it's a scripting language that can automate everything from emails, to file moving, to web development, to even cars. Why don't people like scripting languages more?

## Data Structures and Algorithms

Data Structures and Algorithms are perhaps the most sought after concept in interviews, which has led a lot of people to discount the process entirely, but you know, I don't blame tech firms for using data structures and algorithms questions to hire applicants, and here's why. Let's say you want to hire for a back-end software engineer, and your stack is in python's django, for example. Almost no one will have prior python django programming experience, so you have two choices. Either you hire and test all applicants for python django knowledge (which could take your team a year to fill those three vacancies on your team) or you could simply test on concepts that are familiar to backend development -- ask them questions like "what does MVC mean? How would you handle real time communication needs in an app?", or even easier, say you don't even have to write any code, we'll test you on ideas. And that's really the core of what the Data Structures and Algorithms technical interview does, it tests some common knowledge among all developers. So you know, it's not so bad. To get better at Data Structures and Algorithms, I've got Elements of Programming Interviews (EPI in Python), Daily Coding Problem, and Algorithms by Skiena all lined up and ready to go. Hopefully by the end of the year I'll be a better problem solver then.

Well, those are the areas I'll be covering, and maybe documenting here and there through this blog. Hopefully I'll be a better software developer, and maybe I've encouraged you to be a better developer.
